// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.  

CCEffect %{
  techniques:
  - passes:
    - vert: vs
      frag: fs
      blendState:
        targets:
        - blend: true
      rasterizerState:
        cullMode: none
      properties:
        texture: { value: white }
        brightness: { value: 0.0 }
}%


CCProgram vs %{
	precision highp float;

	#include <cc-global>
	#include <cc-local>

	in vec3 a_position;
	in vec4 a_color;
	out vec4 v_color;

	#if USE_TEXTURE
	in vec2 a_uv0;
	out vec2 v_uv0;
	#endif

	void main () {
		vec4 pos = vec4(a_position, 1);

		#if CC_USE_MODEL
		pos = cc_matViewProj * cc_matWorld * pos;
		#else
		pos = cc_matViewProj * pos;
		#endif

		#if USE_TEXTURE
		v_uv0 = a_uv0;
		#endif

		v_color = a_color;

		gl_Position = pos;
	}
}%


CCProgram fs %{
	precision highp float;

	in vec4 v_color;

	#if USE_TEXTURE
	in vec2 v_uv0;
	uniform sampler2D texture;
	#endif
	const float d16 = 0.167; 
	const float d23 = 0.667; 
	uniform PROPERTIES{
		float brightness;
	};

	void main () {
		vec4 color = v_color * texture2D(texture, v_uv0);
        
        float r=color.r;
        float g=color.g;
        float b=color.b;
        
        float maxc=max(max(r,g),b);
        float minc=min(min(r,g),b);
        float h, s, q, p;
        
        if(maxc==minc){
            h=0.0;
            s=0.0;
        }else{
            float dif=maxc-minc;
            if(maxc==r){
                h=60.0*(g-b)/dif;
                if(g<b)h=h+360.0;
            }else if(maxc==g){
                h=60.0*(b-r)/dif+120.0;
            }else if(maxc==b){
                h=60.0*(r-g)/dif+240.0;
            }
            if(maxc+minc<1.0){
                s=dif/(maxc+minc);
            }else{
                s=dif/(2.0-maxc-minc);
            }
        }
        float l=(maxc+minc)/2.0;
        l=min(1.0,l+brightness);
        
        if(l<0.5){
            q=l*(1.0+s);
        }else{
            q=l+s-l*s;
        }
        p=2.0*l-q;
        h=h/360.0;

        float t[3];
        t[0]=h+1.0/3.0;
        t[1]=h;
        t[2]=h-1.0/3.0;
        for(int i=0;i<3;i++){
            if(t[i]<0.0)t[i]+=1.0;
            if(t[i]>1.0)t[i]-=1.0;
        }

        float c[3];
        for(int i=0;i<3;i++){
            float te = t[i];
            if(te<d16){
                c[i]=p+((q-p)*6.0*te);
            }else if(te<0.5){
                c[i]=q;
            }else if(te<d23){
                c[i]=p+((q-p)*6.0*(d23-te));
            }else{
                c[i]=p;
            }
        }

        gl_FragColor = vec4(c[0],c[1],c[2], color.a);
	}
}%
